# Food Delivery Application
Searching restaurants, getting menus, ordering foods and paying for an order.

## Functions:

1. Search a restaurant by name

2. Order food by choosing menu items, quantity and adding a note.

3. User can also fills in delivery address.

4. User should be able to pay.

## Development environment
- **Mongo DB** is running on **docker**, image specified in **docker-compose.yml** file, and started by **docker-compose**.
- **Spring Data Rest** is used for quick DB access and verification.
- **Spring Boot** is used for fast REST API development and independant deployment.
- **Spring Boot Actuator** is used to provide monitoring information. (/health, /metrics... etc.)
- **HAL Browser** is used for quick repository exploration.
- **Lombok** is used to eliminate constructors and getter/setter implementation for cleaner coding style.
- **Spring Cloud** is used to provide infrastructure services.
- **Eureka** is used for microservices registration and discovery.
- **Hystrix** is used as circuit breaker when failure to prevent avalanche in system.
- **RabbitMQ** is used to decouple microservices.
- **WebSocket** is used to send message to UI.
- **RestTemplate** is used to communicate between microservices.

![Food Ordering System Design Diagram](/FoodOrderingSystemDesign.png)

## Services:

The application is built on micro-service design. The application consists of three modules.

1. Restaurant

   * You can search restaurant, get menu of it here.

2. Order

   * You can place your order here.

3. Payment

   * You can pay your order here.

## Flow:

Query restaurant -> query menu -> query menu items -> place order -> pay the bill -> payment service notify order service

## Database:

1. Restaurant

   1. Relational database

   2. Three table - because they are one to many and we can query restaurant info without querying its menu

2. Order

   1. mongoDB
   
   2. The reason I used mongoDB is an order can have various number of items in it.

3. Payment

   1. Relational database (structured, query by id)

## APIs details:

The format of POST request can be found in the test data (Restaurants.json, Orders.json, Payments.json)

1. Restaurant
   
    1. foo.com/restaurants
        
        1. GET passing name(optional), page and size (optional) as parameters and get list of restaurants

        2. DELETE delete all restaurants
        
        3. POST upload a bunch of restaurants
        
    2. foo.com/restaurants/[id]

       1. GET get details of the restaurant
 
       2. DELETE delete the restaurant
       
       3. GET /restaurants/[id]/menus to get the menus of the restaurant
      
    3. foo.com/menus

       1. POST create a list of menus

       2. GET passing page and size (optional) as parameters and get list of menus
       
       3. DELETE delete all menus

    4. foo.com/menus/[id]

       1. GET get info of the menu
       
       2. DELETE delete a menu

    5. foo.com/menu_items
       
       1. GET passing page and size (optional) as parameters and get list of menu items
       
       2. POST upload a list of menu items
       
       3. DELETE delete all menu items
 
    3. foo.com/menu_items/[id]

       1. GET menu items by menu id
       
       2. DELETE delete a menu item
       
       3. GET /menu_items/[id]/price to get the price of it

2. Order

   1. foo.com/orders

      1. POST create a list of orders
      
      2. GET passing page and size (optional) as parameters and get list of orders

   2. foo.com/orders/[id]

      1. GET query info
   
   3. foo.com/orders/[id]/is_paid
   
      1. GET get if the order is paid
      
      2. PUT set if it is paid
   
   4. foo.com/orders/[id]/is_cancelled
   
      1. GET get if the order is cancelled
      
      2. PUT set if it is cancelled

3. Payment

   1. foo.com/payment

      1. GET passing page and size (optional) as parameters and get list of payments
      
      2. POST create a payment
      
   2. foo.com/payment/[id]

      1. GET Return its info

## Guide to upload data with cascading relation

The basic idea is: upload top down in hierarchy.

1. Upload restaurants and get the id from response.

2. Upload menus with the restaurant id they belong to and get the menu id from respons.

3. Upload menu items with the menu id they belong to.

## Order to run

launch restaurant -> upload test data -> launch order -> upload test data -> launch payment

Please note that because we cannot predict id generated by MongoDB, the test data of payment cannot let any order change to payed. The order service will only log a request try to set an inexistent order to payed.

## Getting started
### Start MongoDB, RabbitMQ on Docker
```bash
docker-compose up -d
```
### Check data in MongoDB
Find mongodb container id
```
docker ps
```
Enter mongodb container by typing the first 3 charactters of the container id (ex: '9cd'), then type mongo inside the container to use mongodb shell command.
```
docker exec -it 9cd bash
# mongo                             // open mongo shell
> use test                          // Spring boot use test db as default
> show collections                  // show all collections inside test db
> db.restaurant.find().pretty()     // show all data inside restaurant table
> exit                              // quit mongo shell
> exit                              // exit container shell
```

### Installation
```bash
mvn clean install
```
### Start Eureka
```bash
sh ./start-eureka.sh
```
### Start Hystrix
```bash
sh ./start-hystrix.sh
```
### Start Restaurant Service
```bash
sh ./start-restaurant-service.sh
```
### Start Order Service
```bash
sh ./start-order-service.sh
```
### Start Payment Distribution
```bash
sh ./start-payment-distribution.sh
```
### Start Payment Service
```bash
sh ./start-payment-service.sh
```
### Start Order Complete Updater
```bash
sh ./start-order-complete-updater.sh
```
### Upload Test Menu Items
```bash
cd restaurant-service
sh ./upload-menu-items.sh

Note: default restaurant id for testing: "11111111-1111-1111-11111111111111111".
```
### Explore by HAL Browser
```bash
http://localhost:8001/browser/index.html

port: 8001 can be changed for different services.
```
#### Investigate registerd services in Eureka
```
http://localhost:8761
```
#### Investigate message queue in RabbitMQ
```
http://localhost:15762
Go to Queues -> binder.payments
```
### Checkout application metrics
```
http://localhost:8005/health
http://localhost:8005/env
http://localhost:8005/metrics
http://localhost:8005/mappings

Note: 8005 can be changed for different services.
```
### Test work flow with PostMan
Create an order
```
POST localhost:8002/api/restaurants/11111111-1111-1111-11111111111111111/orders
{
    "restaurantId": "11111111-1111-1111-11111111111111111",
    "items": [
        {
            "name": "menuItem 1",
            "price": 11,
            "quantity": 2
        },
        {
            "name": "menuItem 2",
            "price": 12,
            "quantity": 3
        }
    ],
    "userInfo": {
        "firstName": "first1",
        "lastName": "last1",
        "phone": "14081234567",
        "address": "123 stree1 ave, San Jose, CA 95123"
    }
}
Returns:
Returns:
{
    "id": "5903e81327b884525eb9a5be",
    ...
    "totalPrice": 58,
    ...
}

```
Post a payment for the order
```
POST localhost:8003/api/payments
{
    "amount": 58,
    "orderId": "5903e81327b884525eb9a5be",
    "creditCardInfo": {
        "firstName": "first 1",
        "lastName": "last 1",
        "expiredMonth": "02",
        "expiredYear": "2019",
        "securityCode": "231"
    }
}
```
Check RabbitMQ, you will see a message is queued by payment-distribution and consumed by payment-service.

At the log of order-complet-updater, you will see the following message:
"Receive order = Order(id=5903e81327b884525eb9a5be, ..."
"WebSocketSession[1 current WS(1)-HttpStream(0)-HttpPoll(0), 3 total..."

So the message has been sent out through WebSocket by order-complete-updater.

To see the message with test UI:
```
localhost:8005
Click on "Subscribe to Order Complete Updates" to subscribe the channel.
Click on "Send Test Message" to send out the test JSON object.
```
See the message received at the buttom text box.
```
Subscribed to /topic/orders
sendMessage triggered
{
  "id": "5903e81327b884525eb9a5be",
  "restaurantId": "11111111-1111-1111-11111111111111111",
  "items": [
     {
       "name": "menuItem 1",
       "price": 11,
       "quantity": 2
     },
     {
       "name": "menuItem 2",
       "price": 12,
       "quantity": 3
     }
  "totalPrice": 58,
  "orderTime": 1493428243933,
  "specialNote": "",
  "deliveryTime": 1493486808730,
  "paymentId": "",
  "userInfo": {
     "id": "",
     "firstName": "first1",
     "lastName": "last1",
     "phone": "14081234567",
     "address": "123 stree1 ave, San Jose, CA 95123"
  }
}
```
### Test fallback
Open Hystrix dashboard
```
localhost:7979
```
Monitor order-complete-updater
```
http://localhost:8004/hystrix.stream
```
Stop order-complete-updater.
Post a payment to payment-service.
Watch processPayment error rate jump from 0.0 to 100%.
Watch error message from fallback method in log.
Keep posting the same payment again and again, eventually, see the Circuit status changed to "Opened" from "Closed."
## LICENSE

[MIT](./License.txt)